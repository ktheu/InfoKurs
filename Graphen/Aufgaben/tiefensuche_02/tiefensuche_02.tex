\question[8]
Der gerichtete, gewichtete Graph G sei als dictionary von
dictionaries gegeben. Gehe mit Tiefensuche durch G und
speichere im Verlauf der Tiefensuche in einen dictionary \texttt{min\_nachbar} für jeden
Knoten den billigsten Nachbarn. Falls der Knoten keinen Nachbarn hat,
soll None gespeichert werden.

\begin{solutionbox}{13cm}
\begin{lstlisting}
def explore(v):
    visited[v] = True
    min_kosten = inf
    min_knoten = None
    for w in G[v]:
        if G[v][w] < min_kosten:
            min_kosten = G[v][w]
            min_knoten = w
    min_nachbar[v] = min_knoten
    for w in G[v]:
        if not visited[w]:
            explore(w)

inf = float('inf')
visited = {v : False for v in G}
min_nachbar = {v: None for v in G}
for w in G:
    if not visited[w]:
        explore(w)

\end{lstlisting}
\end{solutionbox}
