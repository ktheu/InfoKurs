* Einfache Algorithmen (collatz, pledge, euklid, sieb des eratosthenes, binäre suche )
* Rekursion (euklid, binäre suche, türme von hanoi)
* Codierung ganzer Zahlen: Dual- und Hexadezimalzahlen, Zweierkomplement
* Codierung von Zeichen: ASCII, Unicode, UTF-8
* Huffman-Algorithmus

* Laufzeitbetrachtungen: Komplexität, O-Notation
* Laufzeitbetrachtungen am Beispiel der Sortieralgorithmen: SelectionSort, BubbleSort, MergeSort, QuickSort, HeapSort

* Objektorientierte Programmierung: Klassen und Objekte, Methoden, Vererbung.
* Abstrakte Datentypen: Liste, Schlange, Keller, Baum und deren Implementierung
* Traversierungen binärer Bäume: preorder, inorder, postorder, Tiefensuche, Breitensuche
* Suchbaum

* Spielbaum: Minmax-Algorithmus und alpha-beta-Algorithmus
* Search: bfs, dfs, greedy, A* und beamsearch

* Hashing: offenes und geschlossenes Hashing

* Graphen: Adjazenzmatrix, Adjazenzlisten, Implementierungen
* Graphenalgorithmen 1: Floyd, bfs, dfs, Erreichbarkeit, Zusammenhangskomponenten, Topologische Sortierung
* Graphenalgorithmen 2: Dijkstra, Bellman-Ford, Kruskal, Jarnik-Prim

* TSP (Traveling Salesman Problem)
* Backtracking (8-Damen-Problem)
* Knapsack-Problem (greedy, dynamische Programmierung)

* P = NP?
* Halteproblem
* Endliche Automaten und formale Sprachen
* Grammatiken
* Turingmaschinen und Berechenbarkeit

* Datenbanken mit SQL

* neuronale Netze


--------------------------------------------

* Rekursion
* Codierung und Kompression von Daten  

* Komplexität von Algorithmen (O-Notation)
* Sortieralgorithmen

* Objektorientierte Programmierung  
* Abstrakte Datentypen: Liste, Schlange, Keller

* Suchverfahren
* Bäume und Graphen

* ausgewählte Algorithmen 

* Endliche Automaten und formale Sprachen

* Datenbanken mit SQL

-------------------------------------
  
   










